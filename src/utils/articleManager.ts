import { Article, ArticleGenerationResult, WordleDailyData } from '@/types/article'
import { ArticleGenerator } from './articleGenerator'
import { ArticleStorage } from './articleStorage'
import { WordleApiService } from './wordleApi'

export interface ArticleManagerOptions {
  autoGenerateDaily?: boolean
  enableCaching?: boolean
  maxRetries?: number
}

export class ArticleManager {
  private static instance: ArticleManager
  private generator: ArticleGenerator
  private storage: ArticleStorage
  private apiService: WordleApiService
  private options: ArticleManagerOptions
  private isGenerating = false

  private constructor(options: ArticleManagerOptions = {}) {
    this.options = {
      autoGenerateDaily: true,
      enableCaching: true,
      maxRetries: 3,
      ...options
    }
    
    this.generator = ArticleGenerator.getInstance()
    this.storage = ArticleStorage.getInstance({ enableCaching: this.options.enableCaching })
    this.apiService = WordleApiService.getInstance()
  }

  public static getInstance(options?: ArticleManagerOptions): ArticleManager {
    if (!ArticleManager.instance) {
      ArticleManager.instance = new ArticleManager(options)
    }
    return ArticleManager.instance
  }

  /**
   * Initialize the article manager
   */
  public async initialize(): Promise<void> {
    try {
      await this.storage.initialize()
      console.log('Article manager initialized successfully')
      
      // Auto-generate articles for today if enabled
      if (this.options.autoGenerateDaily) {
        await this.ensureTodayArticles()
      }
    } catch (error) {
      console.error('Failed to initialize article manager:', error)
    }
  }

  /**
   * Ensure articles exist for today's word
   */
  public async ensureTodayArticles(): Promise<void> {
    try {
      const todayResponse = await this.apiService.getTodayWord()
      
      if (todayResponse.success && todayResponse.data) {
        const hasArticles = await this.storage.hasArticlesForWord(todayResponse.data.word)
        
        if (!hasArticles) {
          console.log(`No articles found for today's word: ${todayResponse.data.word}`)
          await this.generateArticlesForWord(todayResponse.data.word, todayResponse.data)
        } else {
          console.log(`Articles already exist for today's word: ${todayResponse.data.word}`)
        }
      }
    } catch (error) {
      console.error('Failed to ensure today articles:', error)
    }
  }

  /**
   * Generate articles for a specific word
   */
  public async generateArticlesForWord(
    word: string,
    wordData: WordleDailyData,
    force: boolean = false
  ): Promise<ArticleGenerationResult> {
    if (this.isGenerating) {
      return {
        success: false,
        articles: [],
        error: 'Article generation already in progress'
      }
    }

    try {
      this.isGenerating = true
      console.log(`Starting article generation for word: ${word}${force ? ' (forced)' : ''}`)

      // Check if articles already exist (unless forced)
      if (!force) {
        const existingArticles = await this.storage.getArticlesForWord(word)
        if (existingArticles.length > 0) {
          console.log(`Articles already exist for word: ${word}`)
          return {
            success: true,
            articles: existingArticles,
            message: 'Articles already exist for this word'
          }
        }
      }

      // Generate new articles
      const articles = await this.generator.generateArticlesForWord(word, wordData)
      
      // Store articles
      await this.storage.storeArticles(word, articles)
      
      console.log(`Successfully generated and stored ${articles.length} articles for word: ${word}`)
      
      return {
        success: true,
        articles,
        message: `Generated ${articles.length} articles successfully`
      }

    } catch (error) {
      console.error(`Failed to generate articles for word ${word}:`, error)
      return {
        success: false,
        articles: [],
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      }
    } finally {
      this.isGenerating = false
    }
  }

  /**
   * Get articles for today's word
   */
  public async getTodayArticles(): Promise<Article[]> {
    try {
      const todayResponse = await this.apiService.getTodayWord()
      
      if (todayResponse.success && todayResponse.data) {
        return await this.storage.getArticlesForWord(todayResponse.data.word)
      }
      
      return []
    } catch (error) {
      console.error('Failed to get today articles:', error)
      return []
    }
  }

  /**
   * Get articles for a specific word
   */
  public async getArticlesForWord(word: string): Promise<Article[]> {
    try {
      return await this.storage.getArticlesForWord(word)
    } catch (error) {
      console.error(`Failed to get articles for word ${word}:`, error)
      return []
    }
  }

  /**
   * Get articles for a specific date
   */
  public async getArticlesForDate(date: string): Promise<Article[]> {
    try {
      const dateResponse = await this.apiService.getWordForDate(date)
      
      if (dateResponse.success && dateResponse.data) {
        return await this.storage.getArticlesForWord(dateResponse.data.word)
      }
      
      return []
    } catch (error) {
      console.error(`Failed to get articles for date ${date}:`, error)
      return []
    }
  }

  /**
   * Get articles by category
   */
  public async getArticlesByCategory(category: string): Promise<Article[]> {
    try {
      return await this.storage.getArticlesByCategory(category)
    } catch (error) {
      console.error(`Failed to get articles by category ${category}:`, error)
      return []
    }
  }

  /**
   * Search articles
   */
  public async searchArticles(query: string): Promise<Article[]> {
    try {
      return await this.storage.searchArticles(query)
    } catch (error) {
      console.error(`Failed to search articles with query "${query}":`, error)
      return []
    }
  }

  /**
   * Get recent articles
   */
  public async getRecentArticles(limit: number = 10): Promise<Article[]> {
    try {
      return await this.storage.getRecentArticles(limit)
    } catch (error) {
      console.error(`Failed to get recent articles:`, error)
      return []
    }
  }

  /**
   * Get popular articles
   */
  public async getPopularArticles(limit: number = 10): Promise<Article[]> {
    try {
      return await this.storage.getPopularArticles(limit)
    } catch (error) {
      console.error(`Failed to get popular articles:`, error)
      return []
    }
  }

  /**
   * Update article view count
   */
  public async incrementViewCount(articleId: string): Promise<void> {
    try {
      await this.storage.incrementViewCount(articleId)
    } catch (error) {
      console.error(`Failed to increment view count for article ${articleId}:`, error)
    }
  }

  /**
   * Update article like count
   */
  public async incrementLikeCount(articleId: string): Promise<void> {
    try {
      await this.storage.incrementLikeCount(articleId)
    } catch (error) {
      console.error(`Failed to increment like count for article ${articleId}:`, error)
    }
  }

  /**
   * Get article statistics
   */
  public async getArticleStats() {
    try {
      return await this.storage.getArticleStats()
    } catch (error) {
      console.error('Failed to get article statistics:', error)
      return {
        totalArticles: 0,
        totalWords: 0,
        categories: {},
        totalViews: 0,
        totalLikes: 0
      }
    }
  }

  /**
   * Force regenerate articles for a word
   */
  public async forceRegenerateArticles(word: string): Promise<ArticleGenerationResult> {
    try {
      console.log(`Force regenerating articles for word: ${word}`)
      
      // Get word data
      const wordResponse = await this.apiService.getWordForDate(new Date().toISOString().split('T')[0])
      const wordData = wordResponse.success && wordResponse.data ? wordResponse.data : {
        word: word.toUpperCase(),
        wordNumber: 1,
        date: new Date().toISOString().split('T')[0],
        source: 'Force Regenerate',
        isReal: false
      }
      
      // Clear existing articles
      // Note: In a real implementation, you might want to archive instead of delete
      
      // Generate new articles
      return await this.generateArticlesForWord(word, wordData, true) // Pass true for force
      
    } catch (error) {
      console.error(`Failed to force regenerate articles for word ${word}:`, error)
      return {
        success: false,
        articles: [],
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      }
    }
  }

  /**
   * Get cache statistics
   */
  public getCacheStats() {
    return this.apiService.getCacheStats()
  }

  /**
   * Clear all caches
   */
  public clearCaches(): void {
    this.apiService.clearCache()
    console.log('All caches cleared')
  }

  /**
   * Clean expired cache entries
   */
  public cleanExpiredCaches(): void {
    this.apiService.cleanExpiredCache()
    console.log('Expired cache entries cleaned')
  }

  /**
   * Check if articles are being generated
   */
  public isGeneratingArticles(): boolean {
    return this.isGenerating
  }

  /**
   * Get current status
   */
  public async getStatus(): Promise<{
    isInitialized: boolean
    isGenerating: boolean
    todayWord?: string
    totalArticles: number
    cacheStats: Record<string, unknown>
  }> {
    try {
      const stats = await this.storage.getArticleStats()
      const todayResponse = await this.apiService.getTodayWord()
      const cacheStats = this.apiService.getCacheStats()
      
      return {
        isInitialized: true,
        isGenerating: this.isGenerating,
        todayWord: todayResponse.success ? todayResponse.data?.word : undefined,
        totalArticles: stats.totalArticles,
        cacheStats
      }
    } catch (error) {
      console.error('Failed to get status:', error)
      return {
        isInitialized: false,
        isGenerating: this.isGenerating,
        totalArticles: 0,
        cacheStats: {}
      }
    }
  }
} 